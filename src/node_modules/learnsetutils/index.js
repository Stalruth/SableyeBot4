const getChainLearnset = async (data, pokemon) => {
  const name = pokemon['name'];
  let learnset = (await data.learnsets.get(pokemon['id']))?.learnset;

  if(!learnset) {
    learnset = (await data.learnsets.get(pokemon['baseSpecies'])).learnset;
  }

  const chain = {
    name: name,
    learnset: learnset,
  };

  if(pokemon['prevo']) {
    return [chain, ...(await getChainLearnset(data, data.species.get(pokemon['prevo'])))];
  }

  return [chain];
};

const moveAvailable = (gen, checkLatestOnly) => {
  return (el) => {
    if(!gen) {
      return true;
    }
    const moveGen = el[0];
    if(moveGen == gen) {
      return (!checkLatestOnly || el[1] !== 'V');
    }
    if(moveGen < gen && !checkLatestOnly) {
      return true;
    }
    return false;
  };
};

const getMoves = function(data, learnsetChain, moveCheck) {
  const moveset = [];

  learnsetChain.forEach(learnset => {
    for(const moveId in learnset.learnset) {
      const move = data.moves.get(moveId);
      if(learnset.learnset[moveId].some(moveCheck) && !!move) {
        moveset.push(move['name']);
      }
    }
  });
  return moveset;
};

const decodeLearnString = (learnString) => {
  const method = learnString[1];
  const extra = learnString.substr(2);

  const sourceNames = {
    E:"egg",
    D:"dream world",
    S:"event",
    L:"level up",
    M:"TM, HM or TR",
    T:"tutor",
    X:"egg, traded back",
    Y:"event, traded back",
    V:"VC transfer"
  };

  let result = sourceNames[method];
  if(extra !== '') {
    result += ` (${extra})`;
  }
  return result;
};

const hasMove = async (data, pokemon, move, isVgc) => {
  const learnsetChain = await getChainLearnset(data, pokemon);
  const genCheck = moveAvailable(data.num, isVgc);
  for(const link of learnsetChain) {
    if(link.learnset[move['id']] && link.learnset[move['id']].some(el=>genCheck(el))) {
      return true;
    }
  }
  return false;
}

module.exports = {getChainLearnset, moveAvailable, getMoves, decodeLearnString, hasMove};
