'use strict';

const Dex = require('@pkmn/dex');
const Data = require('@pkmn/data');
const WordGraphs = require('word-graphs');
const toArray = require('dexdata-toarray');
const dataSearch = require('datasearch');

const graphs = {
  all: new WordGraphs.Trie(),
};

['abilities','moves','items','species','natures'].forEach(type=>{
  graphs[type] = new WordGraphs.MinimalWordGraph();
  toArray(Dex.Dex[type])
      .map(e=>e.id)
      .sort()
      .forEach(el=>{
        graphs[type].add(el);
        graphs.all.add(el);
      });
});

function complete(type) {
  function completeEntity(id) {
    return graphs[type].startsWith(Data.toID(id)).slice(0,25).map((e,i) => {
      return {
        name: Dex.Dex[type].get(e).name,
        value: e,
      };
    });
  }
  return completeEntity;
}

function completeAll(id) {
  return graphs.all
      .startsWith(Data.toID(id))
      .slice(0,25)
      .map(e => {
        const distance = {
          ability: dataSearch(Dex.Dex.abilities, Data.toID(e)),
          item: dataSearch(Dex.Dex.items, Data.toID(e)),
          move: dataSearch(Dex.Dex.moves, Data.toID(e)),
          nature: dataSearch(Dex.Dex.natures, Data.toID(e)),
          pokemon: dataSearch(Dex.Dex.species, Data.toID(e)),
        };

        let mostAccurate = null;
        ['pokemon','move','ability','item','nature'].forEach((el) => {
          if(distance[el] === null) {
            return;
          }
          if(mostAccurate === null) {
            mostAccurate = el;
            return;
          }
          if(distance[el].distance < distance[mostAccurate].distance) {
            mostAccurate = el;
            return;
          }
        });

        return {
          name: distance[mostAccurate].result.name,
          value: e,
        };
    });
}

module.exports = {
  completeAbility: complete('abilities'),
  completeMove: complete('moves'),
  completeItem: complete('items'),
  completePokemon: complete('species'),
  completeAll: completeAll,
};

