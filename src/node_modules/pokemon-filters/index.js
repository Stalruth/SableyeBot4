const Data = require('@pkmn/data');

const dataSearch = require('datasearch');
const { hasMove } = require('learnsetutils');
const { damageTaken } = require('typecheck');

function getStat(pokemon, stat) {
  if(stat === 'weightkg') {
    return pokemon[stat];
  }
  if(stat === 'bst') {
    const s = pokemon['baseStats'];
    return s.hp + s.atk + s.def + s.spa + s.spd + s.spe;
  } else {
    return pokemon['baseStats'][stat];
  }
}

function statFilterFactory(stat) {
  const statNames = {
    hp: 'HP',
    atk: 'Attack',
    def: 'Defence',
    spa: 'Special Attack',
    spd: 'Special Defence',
    spe: 'Speed',
    bst: 'Base Stat Total',
    weightkg: 'Weight',
  };
  const getArticle = (stat) => {
    return stat === 'hp' || stat === 'atk' ? 'an' : 'a';
  };
  const getSuffix = (stat) => {
    return stat === 'bst' || stat === 'weightkg' ? '' : 'stat '
  }
  return (query) => {
    if(!isNaN(Number(query))) {
      return {
        description: `Has ${getArticle(stat)} ${statNames[stat]} ${getSuffix(stat)}of ${Number(query)}`,
        predicate: (pokemon) => {
          return getStat(pokemon, stat) === Number(query);
        }
      };
    }
    if(query.indexOf('-') !== -1) {
      const range = query.split('-').map(e=>Number(e));
      if(range.length === 2 && !range.some(e=>isNaN(e)) && range[0] < range[1]) {
        return {
          description: `Has ${getArticle(stat)} ${statNames[stat]} ${getSuffix(stat)}between ${range[0]} and ${range[1]}`,
          predicate: (pokemon) => {
            return getStat(pokemon, stat) >= range[0] && getStat(pokemon, stat) <= range[1];
          }
        };
      }
    }
    const compValue = Number(query.substr(1));
    if(!isNaN(compValue)) {
      const operator = query[0];
      if(operator === '>') {
        return {
          description: `Has ${getArticle(stat)} ${statNames[stat]} ${getSuffix(stat)}greater than ${compValue}`,
          predicate: (pokemon) => {
            return getStat(pokemon, stat) > compValue;
          }
        };
      }
      if(operator === '<') {
        return {
          description: `Has ${getArticle(stat)} ${statNames[stat]} ${getSuffix(stat)}lower than ${compValue}`,
          predicate: (pokemon) => {
            return getStat(pokemon, stat) < compValue;
          }
        };
      }
      throw query;
    }
    throw query;
  };
}

const filterFactory = {
  ability: (data, abilityId) => {
    const ability = dataSearch(data.abilities, Data.toID(abilityId))?.result;
    if(!ability) {
      throw abilityId;
    }

    return {
      description: `Has the ability ${ability['name']}`,
      predicate: (pokemon) => {
        return ['0','1','H'].some(slot=>pokemon['abilities'][slot] === ability['name'])
      },
    };
  },
  type: (data, typeId) => {
    const type = dataSearch(data.types, Data.toID(typeId))?.result;
    if(!type) {
      throw typeId;
    }

    if(typeId.startsWith('!')) {
      return {
        description: `Is not ${type['name']}-type`,
        predicate: (pokemon) => {
          return !(pokemon['types'].some(el=>el===type['name']));
        },
      };
    } else {
      return {
        description: `Is ${type['name']}-type`,
        predicate: (pokemon) => {
          return pokemon['types'].some(el=>el===type['name']);
        },
      };
    }
  },
  move: (data, moveId, vgc) => {
    const move = dataSearch(data.moves, Data.toID(moveId))?.result;
    if(!move) {
      throw moveId;
    }

    return {
      async: true,
      description: `Has the move ${move['name']}`,
      predicate: async (pokemon) => {
        return await hasMove(data, pokemon, move, vgc)
      },
    };
  },
  hp: statFilterFactory('hp'),
  atk: statFilterFactory('atk'),
  def: statFilterFactory('def'),
  spa: statFilterFactory('spa'),
  spd: statFilterFactory('spd'),
  spe: statFilterFactory('spe'),
  bst: statFilterFactory('bst'),
  weightkg: statFilterFactory('weightkg'),
  weakness: (data, typeId) => {
    const type = dataSearch(data.types, Data.toID(typeId))?.result;
    if(!type) {
      throw typeId;
    }

    return {
      description: `Is weak to ${type.name}`,
      predicate: (pokemon) => {
        return damageTaken(data, pokemon.types, type.id) > 1;
      }
    };
  },
  resist: (data, typeId) => {
    const type = dataSearch(data.types, Data.toID(typeId))?.result;
    if(!type) {
      throw typeId;
    }

    return {
      description: `Resists ${type.name}`,
      predicate: (pokemon) => {
        return damageTaken(data, pokemon.types, type.id) < 1;
      }
    };
  },
  egggroup: (eggGroup) => {
    return {
      description: `Is in the ${eggGroup} egg group`,
      predicate: (pokemon) => {
        return pokemon['eggGroups'].some(e=>e===eggGroup);
      },
    };
  },
};

async function applyFilters(pokemon, filters, threshold) {
  return (await Promise.all(pokemon.map(async (candidate) => {
    let score = 0;

    score = (await Promise.all(filters.map(async (filter)=> {
      return (await filter.predicate(candidate)) ? 1 : 0;
    }))).reduce((acc, cur) => {return acc + cur;}, 0);

    return score >= threshold ? candidate : undefined;
  }))).filter(el=>!!el);
}

module.exports = { filterFactory, applyFilters };
