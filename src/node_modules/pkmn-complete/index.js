'use strict';

const Dex = require('@pkmn/dex');
const Data = require('@pkmn/data');
const WordGraphs = require('word-graphs');

const { natDexData } = require('natdexdata');
const toArray = require('dexdata-toarray');
const dataSearch = require('datasearch');

const graphs = {
  all: new WordGraphs.Trie(),
};

['abilities','moves','items','species','natures','types'].forEach(type=>{
  graphs[type] = new WordGraphs.MinimalWordGraph();
  toArray(natDexData[type])
      .map(e=>e.id)
      .sort()
      .forEach(el=>{
        graphs[type].add(el);
        if(['abilities','moves','items','species','natures'].includes(type)) {
          graphs.all.add(el);
        }
      });
});

function complete(type) {
  function completeEntity(id) {
    return graphs[type].startsWith(Data.toID(id)).slice(0,25).map((e,i) => {
      return {
        name: natDexData[type].get(e).name,
        value: e,
      };
    });
  }
  return completeEntity;
}

function completeFilterType(id) {
  const negate = id.startsWith('!') ? '!' : '';
  return graphs.types.startsWith(Data.toID(id)).slice(0,25).map((e,i) => {
    return {
      name: `${negate}${natDexData.types.get(e).name}`,
      value: `${negate}${e}`,
    };
  });
}

function completeAll(id) {
  return graphs.all
      .startsWith(Data.toID(id))
      .slice(0,25)
      .map(e => {
        const distance = {
          ability: dataSearch(natDexData.abilities, Data.toID(e)),
          item: dataSearch(natDexData.items, Data.toID(e)),
          move: dataSearch(natDexData.moves, Data.toID(e)),
          nature: dataSearch(natDexData.natures, Data.toID(e)),
          pokemon: dataSearch(natDexData.species, Data.toID(e)),
        };

        let mostAccurate = null;
        ['pokemon','move','ability','item','nature'].forEach((el) => {
          if(distance[el] === null) {
            return;
          }
          if(mostAccurate === null) {
            mostAccurate = el;
            return;
          }
          if(distance[el].distance < distance[mostAccurate].distance) {
            mostAccurate = el;
            return;
          }
        });

        return {
          name: distance[mostAccurate].result.name,
          value: e,
        };
    });
}

module.exports = {
  completeAbility: complete('abilities'),
  completeMove: complete('moves'),
  completeItem: complete('items'),
  completePokemon: complete('species'),
  completeType: complete('types'),
  completeFilterType,
  completeAll,
};

